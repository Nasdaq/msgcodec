/*
 * Copyright (c) 2014 Cinnober Financial Technology AB, Stockholm,
 * Sweden. All rights reserved.
 * 
 * This software is the confidential and proprietary information of
 * Cinnober Financial Technology AB, Stockholm, Sweden. You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered into
 * with Cinnober.
 * 
 * Cinnober makes no representations or warranties about the suitability
 * of the software, either expressed or implied, including, but not limited
 * to, the implied warranties of merchantibility, fitness for a particular
 * purpose, or non-infringement. Cinnober shall not be liable for any
 * damages suffered by licensee as a result of using, modifying, or
 * distributing this software or its derivatives.
 */

package com.cinnober.msgcodec.blink;

import com.cinnober.msgcodec.Accessor;
import com.cinnober.msgcodec.ConstructorFactory;
import com.cinnober.msgcodec.Factory;
import com.cinnober.msgcodec.FieldAccessor;
import com.cinnober.msgcodec.FieldDef;
import com.cinnober.msgcodec.GroupDef;
import com.cinnober.msgcodec.IgnoreAccessor;
import com.cinnober.msgcodec.JavaClassGroupTypeAccessor;
import com.cinnober.msgcodec.ProtocolDictionary;
import com.cinnober.msgcodec.TypeDef;
import com.cinnober.msgcodec.util.ByteArrays;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import static org.objectweb.asm.Opcodes.*;
import org.objectweb.asm.Type;
import org.objectweb.asm.commons.GeneratorAdapter;
import org.objectweb.asm.commons.Method;
import org.objectweb.asm.util.CheckClassAdapter;
import org.objectweb.asm.util.TraceClassVisitor;

/**
 *
 * @author mikael.brannstrom
 */
public class CodeGenerator {
    private static final String GENERATED_CLASS_INTERNALNAME = "com/cinnober/msgcodec/blink/GeneratedBlinkCodec";
    private static final Logger log = Logger.getLogger(CodeGenerator.class.getName());

    public byte[] generateClass(ProtocolDictionary dict, int suffix) {
        if (!dict.isBound()) {
            throw new IllegalArgumentException("Dictionary is not bound");
        }

        ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
        ClassVisitor cv = classWriter;
        StringWriter traceString = null;
        if (log.isLoggable(Level.FINER)) {
            traceString = new StringWriter();
            cv = new TraceClassVisitor(cv, new PrintWriter(traceString));
        }
        cv = new CheckClassAdapter(cv);
        if (dict.getBinding().getGroupTypeAccessor() == JavaClassGroupTypeAccessor.INSTANCE) {
            generateJCodec(cv, dict, suffix);
        } else {
            throw new UnsupportedOperationException("Non JavaClassGroupTypeAccessor is not supported");
        }
        byte[] bytes = classWriter.toByteArray();

        if (log.isLoggable(Level.FINE)) {
            log.log(Level.FINE, "Generated codec class " + GENERATED_CLASS_INTERNALNAME + suffix + " for dictionary UID: " + dict.getUID());
            if (log.isLoggable(Level.FINER)) {
                log.finer("Generated code (#"+suffix+"):\n" + traceString.toString());
            }
            if (log.isLoggable(Level.FINEST)) {
                log.finest("Generated bytecode (#"+suffix+"):\n" + ByteArrays.toHex(bytes, 0, bytes.length, 1, 8, 32));
            }
        }
        return bytes;
    }

    private void generateJCodec(ClassVisitor cv, ProtocolDictionary dict, int suffix) {

        final String genClassInternalName = GENERATED_CLASS_INTERNALNAME + suffix;
        cv.visit(V1_7, ACC_PUBLIC + ACC_FINAL, genClassInternalName, null,
                "com/cinnober/msgcodec/blink/GeneratedJavaClassCodec", null);

        generateJConstructorAndFields(dict, cv, genClassInternalName);
        generateJReadStaticGroup(dict, cv, genClassInternalName);
        generateJWriteStaticGroup(dict, cv, genClassInternalName);
        generateJWriteStaticGroupWithId(dict, cv, genClassInternalName);
        generateJWriteStaticGroupWithIdSwitch(dict, cv, genClassInternalName);
        generateJReadStaticGroupSwitch(dict, cv, genClassInternalName);

        cv.visitEnd();
    }

    private void generateJWriteStaticGroupWithId(ProtocolDictionary dict, ClassVisitor cv, String genClassInternalName) {
        for (GroupDef group : dict.getGroups()) {
            Class<?> groupType = (Class) group.getGroupType();
            String groupDescriptor = Type.getDescriptor(groupType);
            //String groupInternalName = Type.getInternalName(groupType);
            MethodVisitor writeidmv = cv.visitMethod(
                    ACC_PRIVATE,
                    "writeStaticGroupWithId",
                    "(Ljava/io/OutputStream;" + groupDescriptor + ")V",
                    null,
                    new String[] { "java/io/IOException" });
            writeidmv.visitCode();
            int nextWriteidVar = 3;

            if (group.getId() != -1) {
                // write with id
                writeidmv.visitVarInsn(ALOAD, 1); // out
                writeidmv.visitLdcInsn(group.getId());
                writeidmv.visitMethodInsn(INVOKESTATIC, "com/cinnober/msgcodec/blink/BlinkOutput", "writeUInt32", "(Ljava/io/OutputStream;I)V", false);
                writeidmv.visitVarInsn(ALOAD, 0); // this
                writeidmv.visitVarInsn(ALOAD, 1); // out
                writeidmv.visitVarInsn(ALOAD, 2); // obj
                writeidmv.visitMethodInsn(INVOKEVIRTUAL, genClassInternalName, "writeStaticGroup", "(Ljava/io/OutputStream;" + groupDescriptor + ")V", false);
                writeidmv.visitInsn(RETURN);
            } else {
                // write with id
                writeidmv.visitLdcInsn("No group id");
                writeidmv.visitTypeInsn(NEW, "java/lang/IllegalArgumentException");
                writeidmv.visitInsn(DUP);
                writeidmv.visitMethodInsn(INVOKESPECIAL, "java/lang/IllegalArgumentException", "<init>", "(Ljava/lang/String;)V", false);
                writeidmv.visitInsn(ATHROW);
            }

            // end
            writeidmv.visitMaxs(3, nextWriteidVar); // PENDING: maxStack
            writeidmv.visitEnd();
        }
    }

    private void generateJWriteStaticGroup(ProtocolDictionary dict, ClassVisitor cv, String genClassInternalName) {
        for (GroupDef group : dict.getGroups()) {
            Class<?> groupType = (Class) group.getGroupType();
            String groupDescriptor = Type.getDescriptor(groupType);
            //String groupInternalName = Type.getInternalName(groupType);
            MethodVisitor writemv = cv.visitMethod(
                    ACC_PRIVATE,
                    "writeStaticGroup",
                    "(Ljava/io/OutputStream;" + groupDescriptor + ")V",
                    null,
                    new String[] { "java/io/IOException" });
            writemv.visitCode();
            int nextWriteVar = 3;

            // fields
            for (FieldDef field : group.getFields()) {

                writemv.visitVarInsn(ALOAD, 1); // output stream

                Class<?> javaClass = field.getJavaClass();
                Accessor<?,?> accessor = field.getAccessor();
                if (accessor.getClass() == FieldAccessor.class) {
                    Field f = ((FieldAccessor)accessor).getField();
                    writemv.visitVarInsn(ALOAD, 2);
                    writemv.visitFieldInsn(GETFIELD, Type.getInternalName(f.getDeclaringClass()), f.getName(), Type.getDescriptor(f.getType()));
                } else if (accessor.getClass() == IgnoreAccessor.class) {
                    writemv.visitInsn(NULL);
                } else {
                    writemv.visitVarInsn(ALOAD, 2);
                    writemv.visitFieldInsn(GETFIELD, genClassInternalName,
                            "accessor_" + group.getName() + "_" + field.getName(),
                            "com/cinnober/msgcodec/Accessor");
                    writemv.visitMethodInsn(INVOKEINTERFACE, "com/cinnober/msgcodec/Accessor", "getValue",
                            "(Ljava/lang/Object;)Ljava/lang/Object;", true);
                    if (javaClass.isPrimitive()) {
                        writemv.visitTypeInsn(CHECKCAST, Type.getInternalName(box(javaClass)));
                        unbox(writemv, javaClass);
                    } else {
                        writemv.visitTypeInsn(CHECKCAST, Type.getInternalName(javaClass));
                    }
                }
                // the output stream and the value is now on the stack
                generateEncodeValue(writemv, field.isRequired(), field.getType(), javaClass, field.getComponentJavaClass());
            }

            // end write
            writemv.visitInsn(RETURN);
            writemv.visitMaxs(4, nextWriteVar); // PENDING: maxStack
            writemv.visitEnd();
        }
    }

    private void generateEncodeValue(MethodVisitor mv, boolean required, TypeDef type,
            Class<?> javaClass, Class<?> componentJavaClass) {

        if (javaClass.isPrimitive() && !required) {
            box(mv, javaClass);
        } else if (!javaClass.isPrimitive() && required) {
            unbox(mv, javaClass);
        }
        String blinkOutput = "com/cinnober/msgcodec/blink/BlinkOutput";
        switch (type.getType()) {
            case INT8:
                if (required) {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeInt8", "(Ljava/io/OutputStream;B)V", false);
                } else {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeInt8Null", "(Ljava/io/OutputStream;Ljava/lang/Byte;)V", false);
                }
                break;
            case UINT8:
                if (required) {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeUInt8", "(Ljava/io/OutputStream;B)V", false);
                } else {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeUInt8Null", "(Ljava/io/OutputStream;Ljava/lang/Byte;)V", false);
                }
                break;
            case INT16:
                if (required) {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeInt16", "(Ljava/io/OutputStream;S)V", false);
                } else {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeInt16Null", "(Ljava/io/OutputStream;Ljava/lang/Short;)V", false);
                }
                break;
            case UINT16:
                if (required) {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeUInt16", "(Ljava/io/OutputStream;S)V", false);
                } else {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeUInt16Null", "(Ljava/io/OutputStream;Ljava/lang/Short;)V", false);
                }
                break;
            case INT32:
                if (required) {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeInt32", "(Ljava/io/OutputStream;I)V", false);
                } else {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeInt32Null", "(Ljava/io/OutputStream;Ljava/lang/Integer;)V", false);
                }
                break;
            case UINT32:
                if (required) {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeUInt32", "(Ljava/io/OutputStream;I)V", false);
                } else {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeUInt32Null", "(Ljava/io/OutputStream;Ljava/lang/Integer;)V", false);
                }
                break;
            case INT64:
                if (required) {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeInt64", "(Ljava/io/OutputStream;J)V", false);
                } else {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeInt64Null", "(Ljava/io/OutputStream;Ljava/lang/Long;)V", false);
                }
                break;
            case UINT64:
                if (required) {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeUInt64", "(Ljava/io/OutputStream;J)V", false);
                } else {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeUInt64Null", "(Ljava/io/OutputStream;Ljava/lang/Long;)V", false);
                }
                break;
            case FLOAT32:
                if (required) {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeFloat32", "(Ljava/io/OutputStream;F)V", false);
                } else {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeFloat32Null", "(Ljava/io/OutputStream;Ljava/lang/Float;)V", false);
                }
                break;
            case FLOAT64:
                if (required) {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeFloat64", "(Ljava/io/OutputStream;D)V", false);
                } else {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeFloat64Null", "(Ljava/io/OutputStream;Ljava/lang/Double;)V", false);
                }
                break;
            case BIGINT:
                if (required) {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeBigInt", "(Ljava/io/OutputStream;Ljava/math/BigInteger;)V", false);
                } else {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeBigIntNull", "(Ljava/io/OutputStream;Ljava/math/BigInteger;)V", false);
                }
                break;
            case DECIMAL:
                if (required) {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeDecimal", "(Ljava/io/OutputStream;Ljava/math/BigDecimal;)V", false);
                } else {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeDecimalNull", "(Ljava/io/OutputStream;Ljava/math/BigDecimal;)V", false);
                }
                break;
            case BIGDECIMAL:
                if (required) {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeBigDecimal", "(Ljava/io/OutputStream;Ljava/math/BigDecimal;)V", false);
                } else {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeBigDecimalNull", "(Ljava/io/OutputStream;Ljava/math/BigDecimal;)V", false);
                }
                break;
            case STRING:
                if (required) {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeStringUTF8", "(Ljava/io/OutputStream;Ljava/lang/String;)V", false);
                } else {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeStringUTF8Null", "(Ljava/io/OutputStream;Ljava/lang/String;)V", false);
                }
                break;
            case BINARY:
                if (required) {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeBinary", "(Ljava/io/OutputStream;[B)V", false);
                } else {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeBinaryNull", "(Ljava/io/OutputStream;|B)V", false);
                }
                break;
            case BOOLEAN:
                if (required) {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeBoolean", "(Ljava/io/OutputStream;Z)V", false);
                } else {
                    mv.visitMethodInsn(INVOKESTATIC, blinkOutput, "writeBooleanNull", "(Ljava/io/OutputStream;Ljava/lang/Boolean;)V", false);
                }
                break;
//            case ENUM:
//                if (javaClass.isEnum()) {
//                    if (required) {
//
//                    } else {
//
//                    }
//                }
            default:
                // FIXME: throw exception here
                mv.visitInsn(POP); // just a marker
        }
    }


    private void generateJReadStaticGroup(ProtocolDictionary dict, ClassVisitor cv, String genClassInternalName) {
        for (GroupDef group : dict.getGroups()) {
            Class<?> groupType = (Class) group.getGroupType();
            String groupDescriptor = Type.getDescriptor(groupType);
            String groupInternalName = Type.getInternalName(groupType);
            MethodVisitor readmv = cv.visitMethod(
                    ACC_PRIVATE,
                    "readStaticGroup_" + group.getName(),
                    "(Lcom/cinnober/msgcodec/util/LimitInputStream;)" + groupDescriptor,
                    null,
                    new String[] { "java/io/IOException" });
            readmv.visitCode();
            int nextReadVar = 2;

            Factory<?> factory = group.getFactory();
            if (factory.getClass() == ConstructorFactory.class) {
                // read, create instance
                readmv.visitTypeInsn(NEW, groupInternalName);
                readmv.visitInsn(DUP);
                readmv.visitMethodInsn(INVOKESPECIAL, groupInternalName, "<init>", "()V", false);
            } else {
                // read, create instance
                readmv.visitVarInsn(ALOAD, 0); // this
                readmv.visitFieldInsn(GETFIELD, genClassInternalName, "factory_" + group.getName(), "com/cinnober/msgcodec/Factory");
                readmv.visitMethodInsn(INVOKEINTERFACE, "com/cinnober/msgcodec/Factory", "newInstance",
                        "()Ljava/lang/Object;", true);
                readmv.visitTypeInsn(CHECKCAST, groupInternalName);
            }
            final int readInstanceVar = nextReadVar++;
            readmv.visitVarInsn(ASTORE, readInstanceVar);

            // fields
            for (FieldDef field : group.getFields()) {
                // TODO: generate read instructions
            }

            // end read
            readmv.visitVarInsn(ALOAD, readInstanceVar);
            readmv.visitInsn(ARETURN);
            readmv.visitMaxs(4, nextReadVar); // PENDING: maxStack
            readmv.visitEnd();
        }
    }
    private void generateJConstructorAndFields(ProtocolDictionary dict, ClassVisitor cv, String genClassInternalName) {
        MethodVisitor ctormv;
        ctormv = cv.visitMethod(ACC_PUBLIC, "<init>", "(Lcom/cinnober/msgcodec/blink/BlinkCodec;Lcom/cinnober/msgcodec/ProtocolDictionary;)V", null, null);
        int nextCtorVar = 3;
        ctormv.visitCode();
        ctormv.visitVarInsn(ALOAD, 0);
        ctormv.visitVarInsn(ALOAD, 1);
        ctormv.visitVarInsn(ALOAD, 2);
        ctormv.visitMethodInsn(INVOKESPECIAL, "com/cinnober/msgcodec/blink/GeneratedJavaClassCodec", "<init>", "(Lcom/cinnober/msgcodec/blink/BlinkCodec;Lcom/cinnober/msgcodec/ProtocolDictionary;)V", false);

        for (GroupDef group : dict.getGroups()) {
            Class<?> groupType = (Class) group.getGroupType();
            //String groupDescriptor = Type.getDescriptor(groupType);
            //String groupInternalName = Type.getInternalName(groupType);

            Factory<?> factory = group.getFactory();
            if (factory.getClass() != ConstructorFactory.class) {
                // field
                FieldVisitor fv = cv.visitField(ACC_PRIVATE + ACC_FINAL, "factory_" + group.getName(), "com/cinnober/msgcodec/Factory", null, null);
                fv.visitEnd();

                // ctor, init field
                ctormv.visitVarInsn(ALOAD, 0); // this
                ctormv.visitVarInsn(ALOAD, 2); // dict
                ctormv.visitLdcInsn(group.getName());
                ctormv.visitMethodInsn(INVOKEVIRTUAL, "com/cinnober/msgcodec/ProtocolDictionary", "getGroup",
                        "(Ljava/lang/String;)Lcom/cinnober/msgcodec/GroupDef", false);
                ctormv.visitFieldInsn(PUTFIELD, genClassInternalName, "factory_" + group.getName(), "com/cinnober/msgcodec/Factory");
            }
        }

        ctormv.visitMaxs(3, nextCtorVar); // PENDING: maxStack
    }

    private void generateJWriteStaticGroupWithIdSwitch(ProtocolDictionary dict, ClassVisitor cv,
            String genClassInternalName) {
        // method writeStaticGroupWithId - switch
        MethodVisitor mv = cv.visitMethod(ACC_PROTECTED, "writeStaticGroupWithId", "(Ljava/io/OutputStream;Ljava/lang/Object;)V", null, new String[] { "java/io/IOException" });
        int nextVar = 3;
        mv.visitCode();

        mv.visitVarInsn(ALOAD, 2);
        mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Object", "getClass", "()Ljava/lang/Class;", false);
        int classVariable = nextVar++;
        mv.visitInsn(DUP);
        mv.visitVarInsn(ASTORE, classVariable);
        mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Object", "hashCode", "()I", false);

        // switch on class.hashCode()
        Map<Integer,ObjectHashCodeSwitchCase<Class<?>>> casesByHashCode = new TreeMap<>();
        for (GroupDef group : dict.getGroups()) {
            Class<?> groupType = (Class<?>) group.getGroupType();
            int groupHash = groupType.hashCode();
            ObjectHashCodeSwitchCase<Class<?>> hashCase = casesByHashCode.get(groupHash);
            if (hashCase == null) {
                hashCase = new ObjectHashCodeSwitchCase<>(groupHash);
                casesByHashCode.put(hashCase.hashCode, hashCase);
            }
            hashCase.add(groupType);
        }

        Label unknownHashLabel = new Label();
        {
            int[] caseValues = new int[casesByHashCode.size()];
            int i = 0;
            for (int hashCode : casesByHashCode.keySet()) {
                caseValues[i++] = hashCode;
            }
            Label[] caseLabels = new Label[casesByHashCode.size()];
            i = 0;
            for (ObjectHashCodeSwitchCase<Class<?>> hashCase : casesByHashCode.values()) {
                caseLabels[i++] = hashCase.label;
            }
            mv.visitLookupSwitchInsn(unknownHashLabel, caseValues, caseLabels);
        }
        for (ObjectHashCodeSwitchCase<Class<?>> hashCase : casesByHashCode.values()) {
            mv.visitLabel(hashCase.label);
            mv.visitFrame(F_SAME, 0, null, 0, null);
            for (ObjectSwitchCase<Class<?>> classCase : hashCase.cases) {
                mv.visitVarInsn(ALOAD, classVariable);
                mv.visitLdcInsn(classCase.object.getCanonicalName() + ".class");
                mv.visitJumpInsn(IF_ACMPEQ, classCase.label);
            }
        }
        mv.visitLabel(unknownHashLabel);
        mv.visitFrame(F_SAME, 0, null, 0, null);
        mv.visitVarInsn(ALOAD, 0); // this
        mv.visitVarInsn(ALOAD, classVariable);
        mv.visitMethodInsn(INVOKEVIRTUAL, "com/cinnober/msgcodec/blink/GeneratedJavaClassCodec", "unknownObjectType",
                "(Ljava/lang/Class;)Ljava/lang/IllegalArgumentException;", false);
        mv.visitInsn(ATHROW);

        
        for (ObjectHashCodeSwitchCase<Class<?>> hashCase : casesByHashCode.values()) {
            for (ObjectSwitchCase<Class<?>> classCase : hashCase.cases) {
                Class<?> groupType = classCase.object;
                GroupDef group = dict.getGroup(groupType);
                String groupDescriptor = Type.getDescriptor(groupType);
                mv.visitLabel(classCase.label);
                mv.visitFrame(F_SAME, 0, null, 0, null);
                mv.visitVarInsn(ALOAD, 0); // this
                mv.visitVarInsn(ALOAD, 1); // out
                mv.visitVarInsn(ALOAD, 2); // obj
                mv.visitMethodInsn(INVOKEVIRTUAL, genClassInternalName, "writeStaticGroup_" + group.getName(),
                        "(Ljava/io/OutputStream;" + groupDescriptor + ")V", false);
                mv.visitInsn(RETURN);
            }
        }

        mv.visitMaxs(3, nextVar);
        mv.visitEnd();
    } 

    private void generateJReadStaticGroupSwitch(ProtocolDictionary dict, ClassVisitor cv, String genClassInternalName) {
        MethodVisitor mv = cv.visitMethod(ACC_PROTECTED, "readStaticGroup", "(ILcom/cinnober/msgcodec/util/LimitInputStream;)Ljava/lang/Object;", null, new String[] { "java/io/IOException" });
        int nextVar = 3;
        mv.visitCode();

        Map<Integer,Label> labelsByGroupId = new TreeMap<>();
        for (GroupDef group : dict.getGroups()) {
            if (group.getId() != -1) {
                labelsByGroupId.put(group.getId(), new Label());
            }
        }
        mv.visitVarInsn(ILOAD, 1); // group id
        Label unknownGroupIdLabel = new Label();
        {
            int[] caseValues = new int[labelsByGroupId.size()];
            int i = 0;
            for (int groupId : labelsByGroupId.keySet()) {
                caseValues[i++] = groupId;
            }
            Label[] caseLabels = labelsByGroupId.values().toArray(new Label[labelsByGroupId.size()]);
            mv.visitLookupSwitchInsn(unknownGroupIdLabel, caseValues, caseLabels);
        }

        for (Map.Entry<Integer, Label> caseEntry : labelsByGroupId.entrySet()) {
            GroupDef group = dict.getGroup(caseEntry.getKey().intValue());
            Class<?> groupType = (Class) group.getGroupType();
            String groupDescriptor = Type.getDescriptor(groupType);
            //String groupInternalName = Type.getInternalName(groupType);

            mv.visitLabel(caseEntry.getValue());
            mv.visitFrame(F_SAME, 0, null, 0, null);
            mv.visitVarInsn(ALOAD, 0);
            mv.visitVarInsn(ALOAD, 2);
            mv.visitMethodInsn(INVOKEVIRTUAL, genClassInternalName, "readStaticGroup_" + group.getName(), "(Lcom/cinnober/msgcodec/util/LimitInputStream;)" + groupDescriptor, false);
            mv.visitInsn(ARETURN);
        }
        // default case
        mv.visitLabel(unknownGroupIdLabel);
        mv.visitFrame(F_SAME, 0, null, 0, null);
        mv.visitVarInsn(ALOAD, 0);
        mv.visitVarInsn(ILOAD, 1);
        mv.visitMethodInsn(INVOKEVIRTUAL, "com/cinnober/msgcodec/blink/GeneratedJavaClassCodec", "unknownGroupId", "(I)Lcom/cinnober/msgcodec/DecodeException;", false);
        mv.visitInsn(ATHROW);
        mv.visitMaxs(2, nextVar); // PENDING: maxStack
        mv.visitEnd();
    }

    private void unbox(MethodVisitor mv, Class<?> javaClass) {
        if (javaClass == Byte.class || javaClass == byte.class) {
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Byte", "byteValue", "()B", false);
        } else if (javaClass == Short.class || javaClass == short.class) {
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Short", "shortValue", "()S", false);
        } else if (javaClass == Integer.class || javaClass == int.class) {
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false);
        } else if (javaClass == Long.class || javaClass == long.class) {
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Long", "longValue", "()J", false);
        } else if (javaClass == Float.class || javaClass == float.class) {
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Float", "floatValue", "()F", false);
        } else if (javaClass == Double.class || javaClass == double.class) {
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false);
        }
    }
    private void box(MethodVisitor mv, Class<?> javaClass) {
        if (javaClass == Byte.class || javaClass == byte.class) {
            mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte;", false);
        } else if (javaClass == Short.class || javaClass == short.class) {
            mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short;", false);
        } else if (javaClass == Integer.class || javaClass == int.class) {
            mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer;", false);
        } else if (javaClass == Long.class || javaClass == long.class) {
            mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long;", false);
        } else if (javaClass == Float.class || javaClass == float.class) {
            mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float;", false);
        } else if (javaClass == Double.class || javaClass == double.class) {
            mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double;", false);
        }
    }

    private Class<?> unbox(Class<?> javaClass) {
        if (javaClass == Byte.class) {
            return byte.class;
        } else if (javaClass == Short.class) {
            return short.class;
        } else if (javaClass == Integer.class) {
            return int.class;
        } else if (javaClass == Long.class) {
            return long.class;
        } else if (javaClass == Float.class) {
            return float.class;
        } else if (javaClass == Double.class) {
            return double.class;
        }
        return javaClass;
    }
    private Class<?> box(Class<?> javaClass) {
        if (javaClass == byte.class) {
            return Byte.class;
        } else if (javaClass == short.class) {
            return Short.class;
        } else if (javaClass == int.class) {
            return Integer.class;
        } else if (javaClass == long.class) {
            return Long.class;
        } else if (javaClass == float.class) {
            return Float.class;
        } else if (javaClass == double.class) {
            return Double.class;
        }
        return javaClass;
    }

    private static class ObjectHashCodeSwitchCase<T> {
        final int hashCode;
        final Label label = new Label();
        final List<ObjectSwitchCase<T>> cases = new ArrayList<>();

        ObjectHashCodeSwitchCase(int hashCode) {
            this.hashCode = hashCode;
        }
        void add(T object) {
            cases.add(new ObjectSwitchCase<>(object, new Label()));
        }
    }
    private static class ObjectSwitchCase<T> {
        final T object;
        final Label label;

        ObjectSwitchCase(T object, Label label) {
            this.object = object;
            this.label = label;
        }

    }

}
