/*
 * Copyright (c) 2014 Cinnober Financial Technology AB, Stockholm,
 * Sweden. All rights reserved.
 * 
 * This software is the confidential and proprietary information of
 * Cinnober Financial Technology AB, Stockholm, Sweden. You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered into
 * with Cinnober.
 * 
 * Cinnober makes no representations or warranties about the suitability
 * of the software, either expressed or implied, including, but not limited
 * to, the implied warranties of merchantibility, fitness for a particular
 * purpose, or non-infringement. Cinnober shall not be liable for any
 * damages suffered by licensee as a result of using, modifying, or
 * distributing this software or its derivatives.
 */

package com.cinnober.msgcodec.blink;

import com.cinnober.msgcodec.ConstructorFactory;
import com.cinnober.msgcodec.Factory;
import com.cinnober.msgcodec.FieldDef;
import com.cinnober.msgcodec.GroupDef;
import com.cinnober.msgcodec.JavaClassGroupTypeAccessor;
import com.cinnober.msgcodec.ProtocolDictionary;
import com.cinnober.msgcodec.util.ByteArrays;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import static org.objectweb.asm.Opcodes.*;
import org.objectweb.asm.Type;
import org.objectweb.asm.util.CheckClassAdapter;
import org.objectweb.asm.util.TraceClassVisitor;

/**
 *
 * @author mikael.brannstrom
 */
public class CodeGenerator {
    private static final String GENERATED_CLASS_INTERNALNAME = "com/cinnober/msgcodec/blink/GeneratedBlinkCodec";
    private static final Logger log = Logger.getLogger(CodeGenerator.class.getName());

    public byte[] generateClass(ProtocolDictionary dict, int suffix) {
        if (!dict.isBound()) {
            throw new IllegalArgumentException("Dictionary is not bound");
        }

        ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
        ClassVisitor cv = classWriter;
        StringWriter traceString = null;
        if (log.isLoggable(Level.FINER)) {
            traceString = new StringWriter();
            cv = new TraceClassVisitor(cv, new PrintWriter(traceString));
        }
        cv = new CheckClassAdapter(cv);
        if (dict.getBinding().getGroupTypeAccessor() == JavaClassGroupTypeAccessor.INSTANCE) {
            generateJCodec(cv, dict, suffix);
        } else {
            throw new UnsupportedOperationException("Non JavaClassGroupTypeAccessor is not supported");
        }
        byte[] bytes = classWriter.toByteArray();

        if (log.isLoggable(Level.FINE)) {
            log.log(Level.FINE, "Generated codec class " + GENERATED_CLASS_INTERNALNAME + suffix + " for dictionary UID: " + dict.getUID());
            if (log.isLoggable(Level.FINER)) {
                log.finer("Generated code (#"+suffix+"):\n" + traceString.toString());
            }
            if (log.isLoggable(Level.FINEST)) {
                log.finest("Generated bytecode (#"+suffix+"):\n" + ByteArrays.toHex(bytes, 0, bytes.length, 1, 8, 32));
            }
        }
        return bytes;
    }

    private void generateJCodec(ClassVisitor cv, ProtocolDictionary dict, int suffix) {

        final String genClassInternalName = GENERATED_CLASS_INTERNALNAME + suffix;
        cv.visit(V1_7, ACC_PUBLIC + ACC_FINAL, genClassInternalName, null,
                "com/cinnober/msgcodec/blink/GeneratedJavaClassCodec", null);

        generateJConstructorAndFields(dict, cv, genClassInternalName);
        generateJReadStaticGroup(dict, cv, genClassInternalName);
        generateJWriteStaticGroup(dict, cv, genClassInternalName);
        generateJWriteStaticGroupWithId(dict, cv, genClassInternalName);
        generateJWriteStaticGroupWithIdSwitch(dict, cv, genClassInternalName);
        generateJReadStaticGroupSwitch(dict, cv, genClassInternalName);

        cv.visitEnd();
    }

    private void generateJWriteStaticGroupWithId(ProtocolDictionary dict, ClassVisitor cv, String genClassInternalName) {
        for (GroupDef group : dict.getGroups()) {
            Class<?> groupType = (Class) group.getGroupType();
            String groupDescriptor = Type.getDescriptor(groupType);
            //String groupInternalName = Type.getInternalName(groupType);
            MethodVisitor writeidmv = cv.visitMethod(
                    ACC_PRIVATE,
                    "writeStaticGroupWithId",
                    "(Ljava/io/OutputStream;" + groupDescriptor + ")V",
                    null,
                    new String[] { "java/io/IOException" });
            writeidmv.visitCode();
            int nextWriteidVar = 3;

            if (group.getId() != -1) {
                // write with id
                writeidmv.visitVarInsn(ALOAD, 1); // out
                writeidmv.visitLdcInsn(group.getId());
                writeidmv.visitMethodInsn(INVOKESTATIC, "com/cinnober/msgcodec/blink/BlinkOutput", "writeUInt32", "(Ljava/io/OutputStream;I)V", false);
                writeidmv.visitVarInsn(ALOAD, 0); // this
                writeidmv.visitVarInsn(ALOAD, 1); // out
                writeidmv.visitVarInsn(ALOAD, 2); // obj
                writeidmv.visitMethodInsn(INVOKEVIRTUAL, genClassInternalName, "writeStaticGroup", "(Ljava/io/OutputStream;" + groupDescriptor + ")V", false);
                writeidmv.visitInsn(RETURN);
            } else {
                // write with id
                writeidmv.visitLdcInsn("No group id");
                writeidmv.visitTypeInsn(NEW, "java/lang/IllegalArgumentException");
                writeidmv.visitInsn(DUP);
                writeidmv.visitMethodInsn(INVOKESPECIAL, "java/lang/IllegalArgumentException", "<init>", "(Ljava/lang/String;)V", false);
                writeidmv.visitInsn(ATHROW);
            }

            // end
            writeidmv.visitMaxs(3, nextWriteidVar); // PENDING: maxStack
            writeidmv.visitEnd();
        }
    }

    private void generateJWriteStaticGroup(ProtocolDictionary dict, ClassVisitor cv, String genClassInternalName) {
        for (GroupDef group : dict.getGroups()) {
            Class<?> groupType = (Class) group.getGroupType();
            String groupDescriptor = Type.getDescriptor(groupType);
            //String groupInternalName = Type.getInternalName(groupType);
            MethodVisitor writemv = cv.visitMethod(
                    ACC_PRIVATE,
                    "writeStaticGroup",
                    "(Ljava/io/OutputStream;" + groupDescriptor + ")V",
                    null,
                    new String[] { "java/io/IOException" });
            writemv.visitCode();
            int nextWriteVar = 3;

            // fields
            for (FieldDef field : group.getFields()) {
                // TODO: generate write instructions
            }

            // end write
            writemv.visitInsn(RETURN);
            writemv.visitMaxs(4, nextWriteVar); // PENDING: maxStack
            writemv.visitEnd();
        }
    }

    private void generateJReadStaticGroup(ProtocolDictionary dict, ClassVisitor cv, String genClassInternalName) {
        for (GroupDef group : dict.getGroups()) {
            Class<?> groupType = (Class) group.getGroupType();
            String groupDescriptor = Type.getDescriptor(groupType);
            String groupInternalName = Type.getInternalName(groupType);
            MethodVisitor readmv = cv.visitMethod(
                    ACC_PRIVATE,
                    "readStaticGroup_" + group.getName(),
                    "(Lcom/cinnober/msgcodec/util/LimitInputStream;)" + groupDescriptor,
                    null,
                    new String[] { "java/io/IOException" });
            readmv.visitCode();
            int nextReadVar = 2;

            Factory<?> factory = group.getFactory();
            if (factory.getClass() == ConstructorFactory.class) {
                // read, create instance
                readmv.visitTypeInsn(NEW, groupInternalName);
                readmv.visitInsn(DUP);
                readmv.visitMethodInsn(INVOKESPECIAL, groupInternalName, "<init>", "()V", false);
            } else {
                // read, create instance
                readmv.visitVarInsn(ALOAD, 0); // this
                readmv.visitFieldInsn(GETFIELD, genClassInternalName, "factory_" + group.getName(), "com/cinnober/msgcodec/Factory");
                readmv.visitMethodInsn(INVOKEINTERFACE, "com/cinnober/msgcodec/Factory", "newInstance",
                        "()Ljava/lang/Object;", true);
                readmv.visitTypeInsn(CHECKCAST, groupInternalName);
            }
            final int readInstanceVar = nextReadVar++;
            readmv.visitVarInsn(ASTORE, readInstanceVar);

            // fields
            for (FieldDef field : group.getFields()) {
                // TODO: generate read instructions
            }

            // end read
            readmv.visitVarInsn(ALOAD, readInstanceVar);
            readmv.visitInsn(ARETURN);
            readmv.visitMaxs(4, nextReadVar); // PENDING: maxStack
            readmv.visitEnd();
        }
    }
    private void generateJConstructorAndFields(ProtocolDictionary dict, ClassVisitor cv, String genClassInternalName) {
        MethodVisitor ctormv;
        ctormv = cv.visitMethod(ACC_PUBLIC, "<init>", "(Lcom/cinnober/msgcodec/blink/BlinkCodec;Lcom/cinnober/msgcodec/ProtocolDictionary;)V", null, null);
        int nextCtorVar = 3;
        ctormv.visitCode();
        ctormv.visitVarInsn(ALOAD, 0);
        ctormv.visitVarInsn(ALOAD, 1);
        ctormv.visitVarInsn(ALOAD, 2);
        ctormv.visitMethodInsn(INVOKESPECIAL, "com/cinnober/msgcodec/blink/GeneratedJavaClassCodec", "<init>", "(Lcom/cinnober/msgcodec/blink/BlinkCodec;Lcom/cinnober/msgcodec/ProtocolDictionary;)V", false);

        for (GroupDef group : dict.getGroups()) {
            Class<?> groupType = (Class) group.getGroupType();
            //String groupDescriptor = Type.getDescriptor(groupType);
            //String groupInternalName = Type.getInternalName(groupType);

            Factory<?> factory = group.getFactory();
            if (factory.getClass() != ConstructorFactory.class) {
                // field
                FieldVisitor fv = cv.visitField(ACC_PRIVATE + ACC_FINAL, "factory_" + group.getName(), "com/cinnober/msgcodec/Factory", null, null);
                fv.visitEnd();

                // ctor, init field
                ctormv.visitVarInsn(ALOAD, 0); // this
                ctormv.visitVarInsn(ALOAD, 2); // dict
                ctormv.visitLdcInsn(group.getName());
                ctormv.visitMethodInsn(INVOKEVIRTUAL, "com/cinnober/msgcodec/ProtocolDictionary", "getGroup",
                        "(Ljava/lang/String;)Lcom/cinnober/msgcodec/GroupDef", false);
                ctormv.visitFieldInsn(PUTFIELD, genClassInternalName, "factory_" + group.getName(), "com/cinnober/msgcodec/Factory");
            }
        }

        ctormv.visitMaxs(3, nextCtorVar); // PENDING: maxStack
    }

    private void generateJWriteStaticGroupWithIdSwitch(ProtocolDictionary dict, ClassVisitor cv,
            String genClassInternalName) {
        // method writeStaticGroupWithId - switch
        MethodVisitor mv = cv.visitMethod(ACC_PROTECTED, "writeStaticGroupWithId", "(Ljava/io/OutputStream;Ljava/lang/Object;)V", null, new String[] { "java/io/IOException" });
        int nextVar = 3;
        mv.visitCode();

        mv.visitVarInsn(ALOAD, 2);
        mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Object", "getClass", "()Ljava/lang/Class;", false);
        int classVariable = nextVar++;
        mv.visitInsn(DUP);
        mv.visitVarInsn(ASTORE, classVariable);
        mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Object", "hashCode", "()I", false);

        // switch on class.hashCode()
        Map<Integer,ObjectHashCodeSwitchCase<Class<?>>> casesByHashCode = new TreeMap<>();
        for (GroupDef group : dict.getGroups()) {
            Class<?> groupType = (Class<?>) group.getGroupType();
            int groupHash = groupType.hashCode();
            ObjectHashCodeSwitchCase<Class<?>> hashCase = casesByHashCode.get(groupHash);
            if (hashCase == null) {
                hashCase = new ObjectHashCodeSwitchCase<>(groupHash);
                casesByHashCode.put(hashCase.hashCode, hashCase);
            }
            hashCase.add(groupType);
        }

        Label unknownHashLabel = new Label();
        {
            int[] caseValues = new int[casesByHashCode.size()];
            int i = 0;
            for (int hashCode : casesByHashCode.keySet()) {
                caseValues[i++] = hashCode;
            }
            Label[] caseLabels = new Label[casesByHashCode.size()];
            i = 0;
            for (ObjectHashCodeSwitchCase<Class<?>> hashCase : casesByHashCode.values()) {
                caseLabels[i++] = hashCase.label;
            }
            mv.visitLookupSwitchInsn(unknownHashLabel, caseValues, caseLabels);
        }
        for (ObjectHashCodeSwitchCase<Class<?>> hashCase : casesByHashCode.values()) {
            mv.visitLabel(hashCase.label);
            mv.visitFrame(F_SAME, 0, null, 0, null);
            for (ObjectSwitchCase<Class<?>> classCase : hashCase.cases) {
                mv.visitVarInsn(ALOAD, classVariable);
                mv.visitLdcInsn(classCase.object.getCanonicalName() + ".class");
                mv.visitJumpInsn(IF_ACMPEQ, classCase.label);
            }
        }
        mv.visitLabel(unknownHashLabel);
        mv.visitFrame(F_SAME, 0, null, 0, null);
        mv.visitVarInsn(ALOAD, 0); // this
        mv.visitVarInsn(ALOAD, classVariable);
        mv.visitMethodInsn(INVOKEVIRTUAL, "com/cinnober/msgcodec/blink/GeneratedJavaClassCodec", "unknownObjectType",
                "(Ljava/lang/Class;)Ljava/lang/IllegalArgumentException;", false);
        mv.visitInsn(ATHROW);

        
        for (ObjectHashCodeSwitchCase<Class<?>> hashCase : casesByHashCode.values()) {
            for (ObjectSwitchCase<Class<?>> classCase : hashCase.cases) {
                Class<?> groupType = classCase.object;
                GroupDef group = dict.getGroup(groupType);
                String groupDescriptor = Type.getDescriptor(groupType);
                mv.visitLabel(classCase.label);
                mv.visitFrame(F_SAME, 0, null, 0, null);
                mv.visitVarInsn(ALOAD, 0); // this
                mv.visitVarInsn(ALOAD, 1); // out
                mv.visitVarInsn(ALOAD, 2); // obj
                mv.visitMethodInsn(INVOKEVIRTUAL, genClassInternalName, "writeStaticGroup_" + group.getName(),
                        "(Ljava/io/OutputStream;" + groupDescriptor + ")V", false);
                mv.visitInsn(RETURN);
            }
        }

        mv.visitMaxs(3, nextVar);
        mv.visitEnd();
    } 

    private void generateJReadStaticGroupSwitch(ProtocolDictionary dict, ClassVisitor cv, String genClassInternalName) {
        MethodVisitor mv = cv.visitMethod(ACC_PROTECTED, "readStaticGroup", "(ILcom/cinnober/msgcodec/util/LimitInputStream;)Ljava/lang/Object;", null, new String[] { "java/io/IOException" });
        int nextVar = 3;
        mv.visitCode();

        Map<Integer,Label> labelsByGroupId = new TreeMap<>();
        for (GroupDef group : dict.getGroups()) {
            if (group.getId() != -1) {
                labelsByGroupId.put(group.getId(), new Label());
            }
        }
        mv.visitVarInsn(ILOAD, 1); // group id
        Label unknownGroupIdLabel = new Label();
        {
            int[] caseValues = new int[labelsByGroupId.size()];
            int i = 0;
            for (int groupId : labelsByGroupId.keySet()) {
                caseValues[i++] = groupId;
            }
            Label[] caseLabels = labelsByGroupId.values().toArray(new Label[labelsByGroupId.size()]);
            mv.visitLookupSwitchInsn(unknownGroupIdLabel, caseValues, caseLabels);
        }

        for (Map.Entry<Integer, Label> caseEntry : labelsByGroupId.entrySet()) {
            GroupDef group = dict.getGroup(caseEntry.getKey().intValue());
            Class<?> groupType = (Class) group.getGroupType();
            String groupDescriptor = Type.getDescriptor(groupType);
            //String groupInternalName = Type.getInternalName(groupType);

            mv.visitLabel(caseEntry.getValue());
            mv.visitFrame(F_SAME, 0, null, 0, null);
            mv.visitVarInsn(ALOAD, 0);
            mv.visitVarInsn(ALOAD, 2);
            mv.visitMethodInsn(INVOKEVIRTUAL, genClassInternalName, "readStaticGroup_" + group.getName(), "(Lcom/cinnober/msgcodec/util/LimitInputStream;)" + groupDescriptor, false);
            mv.visitInsn(ARETURN);
        }
        // default case
        mv.visitLabel(unknownGroupIdLabel);
        mv.visitFrame(F_SAME, 0, null, 0, null);
        mv.visitVarInsn(ALOAD, 0);
        mv.visitVarInsn(ILOAD, 1);
        mv.visitMethodInsn(INVOKEVIRTUAL, "com/cinnober/msgcodec/blink/GeneratedJavaClassCodec", "unknownGroupId", "(I)Lcom/cinnober/msgcodec/DecodeException;", false);
        mv.visitInsn(ATHROW);
        mv.visitMaxs(2, nextVar); // PENDING: maxStack
        mv.visitEnd();
    }

    private static class ObjectHashCodeSwitchCase<T> {
        final int hashCode;
        final Label label = new Label();
        final List<ObjectSwitchCase<T>> cases = new ArrayList<>();

        ObjectHashCodeSwitchCase(int hashCode) {
            this.hashCode = hashCode;
        }
        void add(T object) {
            cases.add(new ObjectSwitchCase<T>(object, new Label()));
        }
    }
    private static class ObjectSwitchCase<T> {
        final T object;
        final Label label;

        ObjectSwitchCase(T object, Label label) {
            this.object = object;
            this.label = label;
        }

    }

}
